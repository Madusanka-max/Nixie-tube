<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nixie Tube Stats</title>
  <style>
    body {
      margin: 0;
      background-color: #0b0b0b;
      color: #f0e7d8;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }

    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 60px;
      text-align: center;
      justify-content: center;
    }

    .stat-item {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .tube-group {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      margin-bottom: 10px;
    }

    .tube {
      position: relative;
      width: 90px;
      height: 160px;
      margin: 0;
      background: radial-gradient(circle at center, #111 20%, #000 90%);
      border-radius: 45px;
      border: 5px solid #333;
      box-shadow: inset 0 0 50px #000, 0 0 25px rgba(255, 136, 0, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      animation: tubeGlow 3s infinite ease-in-out;
      perspective: 400px;
    }

    /* Neon gas glow flicker */
    @keyframes tubeGlow {
      0%, 100% { box-shadow: inset 0 0 50px #000, 0 0 25px rgba(255, 136, 0, 0.4), 0 0 30px rgba(255, 100, 0, 0.4); }
      50% { box-shadow: inset 0 0 50px #000, 0 0 35px rgba(255, 150, 0, 0.7), 0 0 50px rgba(255, 120, 0, 0.6); }
    }

    /* Glow halo */
    .tube:before {
      content: "";
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 85%;
      height: 85%;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255, 136, 0, 0.25), transparent 70%);
      filter: blur(15px);
      z-index: 0;
    }

    /* Improved glass reflection */
    .tube:after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 45px;
      background: radial-gradient(ellipse at top left, rgba(255,255,255,0.3) 5%, transparent 60%),
                  radial-gradient(ellipse at bottom right, rgba(255,255,255,0.08) 5%, transparent 70%);
      mix-blend-mode: screen;
      pointer-events: none;
      z-index: 4;
      animation: glassHighlight 8s ease-in-out infinite;
    }

    @keyframes glassHighlight {
      0%, 100% { transform: translateX(-5%) translateY(-5%) rotate(0deg); opacity: 0.4; }
      50% { transform: translateX(5%) translateY(5%) rotate(3deg); opacity: 0.7; }
    }

    /* Curved mesh wires with depth */
    .mesh {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 3;
      pointer-events: none;
      /* Create curved mesh using SVG filter */
      filter: url(#curvedMesh);
    }

    /* SVG filter for mesh curvature */
    .mesh::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: 
        repeating-linear-gradient(to bottom, rgba(200,200,200,0.15) 0px, rgba(200,200,200,0.15) 2px, transparent 2px, transparent 6px),
        repeating-linear-gradient(to right, rgba(200,200,200,0.1) 0px, rgba(200,200,200,0.1) 2px, transparent 2px, transparent 15px);
      transform: translateZ(10px);
      border-radius: 45px;
    }

    /* Number container for depth effect */
    .number-container {
      position: relative;
      z-index: 2;
      transform-style: preserve-3d;
      transform: translateZ(-20px); /* Push numbers behind the mesh */
      filter: blur(0.5px); /* Subtle blur for depth */
      height: 100%;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .number {
      /* Make the number fill the container */
      font-size: 8rem;
      font-weight: bold;
      color: #ff6600;
      text-shadow: 0 0 12px #ff8800, 0 0 35px #ff6600, 0 0 70px #ff3300;
      position: relative;
      opacity: 0;
      line-height: 0.8;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
      padding: 0;
      /* Add a slight 3D effect to mimic real Nixie tubes */
      transform: translateZ(0);
    }

    /* Hide all plus signs by default */
    .plus-sign {
      display: none;
    }

    /* Show the plus sign only after animation completes */
    .show-plus .plus-sign {
      display: block !important;
      position: absolute;
      font-size: 2.5rem;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      color: #ff6600;
      text-shadow: 0 0 10px #ff8800, 0 0 30px #ff6600;
    }

    /* Authentic Nixie tube digit change animation */
    @keyframes nixieDigitChange {
      0% { opacity: 1; transform: translateZ(0); text-shadow: 0 0 12px #ff8800, 0 0 35px #ff6600; }
      40% { opacity: 0.8; transform: translateZ(-5px); text-shadow: 0 0 8px #ff8800, 0 0 25px #ff6600; }
      50% { opacity: 0; transform: translateZ(-10px); text-shadow: none; }
      60% { opacity: 0.3; transform: translateZ(-5px); text-shadow: 0 0 5px #ff8800, 0 0 15px #ff6600; }
      70% { opacity: 0.7; transform: translateZ(0); text-shadow: 0 0 8px #ff8800, 0 0 25px #ff6600; }
      100% { opacity: 1; transform: translateZ(0); text-shadow: 0 0 12px #ff8800, 0 0 35px #ff6600; }
    }

    @keyframes nixieFlicker {
      0% { opacity: 0.7; text-shadow: 0 0 8px #ff8800, 0 0 25px #ff6600; }
      25% { opacity: 1; text-shadow: 0 0 12px #ff8800, 0 0 35px #ff6600; }
      50% { opacity: 0.8; text-shadow: 0 0 10px #ff8800, 0 0 30px #ff6600; }
      75% { opacity: 1; text-shadow: 0 0 14px #ff8800, 0 0 40px #ff6600; }
      100% { opacity: 1; text-shadow: 0 0 12px #ff8800, 0 0 35px #ff6600; }
    }

    .label {
      margin-top: 15px;
      font-size: 1.1rem;
      color: #f0e7d8;
      text-align: center;
      width: 100%;
      font-weight: bold;
    }

    /* Add parallax effect on mouse move */
    .tube:hover .number-container {
      transform: translateZ(-20px) translateY(-2px);
      transition: transform 0.3s ease;
    }
  </style>
</head>
<body>
  <!-- SVG filter for mesh curvature -->
  <svg width="0" height="0" style="position: absolute;">
    <defs>
      <filter id="curvedMesh" x="-20%" y="-20%" width="140%" height="140%">
        <feTurbulence type="turbulence" baseFrequency="0.01 0.05" numOctaves="2" result="turbulence" seed="5"/>
        <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="8" xChannelSelector="R" yChannelSelector="G"/>
      </filter>
    </defs>
  </svg>

  <div class="stats">
    <div class="stat-item">
      <div class="tube-group">
        <div class="tube">
          <div class="mesh"></div>
          <div class="number-container">
            <div class="number" data-target="1">0</div>
            <!-- <div class="plus-sign">+</div> -->
          </div>
        </div>
      </div>
      <div class="label">Years of Innovation</div>
    </div>
    
    <div class="stat-item">
      <div class="tube-group">
        <div class="tube">
          <div class="mesh"></div>
          <div class="number-container">
            <div class="number" data-target="7">0</div>
          </div>
        </div>
      </div>
      <div class="label">Student Associations</div>
    </div>
    
    <div class="stat-item">
      <div class="tube-group">
        <div class="tube">
          <div class="mesh"></div>
          <div class="number-container">
            <div class="number" data-digit="0" data-target="1">0</div>
          </div>
        </div>
        <div class="tube">
          <div class="mesh"></div>
          <div class="number-container">
            <div class="number" data-digit="1" data-target="3">0</div>
          </div>
        </div>
        <div class="tube">
          <div class="mesh"></div>
          <div class="number-container">
            <div class="number" data-digit="2" data-target="">0</div>
          </div>
        </div>
      </div>
      <div class="label">Innovative Projects Showcased</div>
    </div>
    
    <div class="stat-item">
      <div class="tube-group">
        <div class="tube">
          <div class="mesh"></div>
          <div class="number-container">
            <div class="number" data-target="6">0</div>
          </div>
        </div>
      </div>
      <div class="label">Govt. & Private Sector Participation</div>
    </div>
  </div>

  <script>
    // Nixie-like flicker count-up with authentic digit change
    document.addEventListener('DOMContentLoaded', function() {
      // Handle single digit tubes
      const singleDigitTubes = document.querySelectorAll('.tube-group:not(:has(.tube:nth-child(2))) .number');
      
      // Handle multi-digit tubes (specifically for 130)
      const multiDigitGroups = document.querySelectorAll('.tube-group:has(.tube:nth-child(2))');
      
      // Function to simulate authentic Nixie tube digit change
      function changeDigit(el, fromValue, toValue, callback) {
        // Apply the digit change animation
        el.style.animation = 'nixieDigitChange 0.4s ease-in-out';
        
        // During the animation (when opacity is lowest), change the digit
        setTimeout(() => {
          el.textContent = toValue;
        }, 200);
        
        // After animation completes, set up the flicker and call callback
        setTimeout(() => {
          el.style.animation = 'nixieFlicker 2s ease-in-out infinite';
          if (callback) callback();
        }, 400);
      }
      
      function animateSingleDigit(el, target) {
        let warmup = 1000 + Math.random() * 500; // warm-up delay simulating gas ignition
        setTimeout(() => {
          let flickers = 6; // number of random flickers before final
          let i = 0;
          
          function flicker() {
            if (i < flickers) {
              // Random digit flicker with authentic change animation
              const randomDigit = Math.floor(Math.random() * 10);
              changeDigit(el, el.textContent, randomDigit, () => {
                i++;
                setTimeout(flicker, 200 + Math.random() * 300);
              });
            } else {
              // Sequential count-up with authentic digit changes
              let current = 0;
              
              function countUp() {
                if (current < target) {
                  current++;
                  changeDigit(el, current - 1, current, () => {
                    setTimeout(countUp, 300 + Math.random() * 200);
                  });
                } else {
                  // Add the plus sign after counting completes
                  el.parentElement.classList.add('show-plus');
                }
              }
              
              countUp();
            }
          }
          
          // Start with initial flicker
          changeDigit(el, 0, Math.floor(Math.random() * 10), () => {
            i++;
            setTimeout(flicker, 400);
          });
        }, warmup);
      }
      
      function animateMultiDigit(group, targetNumber) {
        const digitElements = group.querySelectorAll('.number');
        const digits = targetNumber.toString().split('');
        
        // Set the target for each digit
        digitElements.forEach((el, index) => {
          if (index < digits.length) {
            el.setAttribute('data-target', digits[index]);
          }
        });
        
        // Staggered animation for each digit
        digitElements.forEach((el, index) => {
          let warmup = 1500 + (index * 300) + Math.random() * 400; // Staggered warm-up
          setTimeout(() => {
            let flickers = 5; // number of flickers before final
            let i = 0;
            
            function flicker() {
              if (i < flickers) {
                const randomDigit = Math.floor(Math.random() * 10);
                changeDigit(el, el.textContent, randomDigit, () => {
                  i++;
                  setTimeout(flicker, 200 + Math.random() * 300);
                });
              } else {
                // Sequential count-up for this digit
                const target = parseInt(el.getAttribute('data-target'), 10);
                let current = 0;
                
                function countUp() {
                  if (current < target) {
                    current++;
                    changeDigit(el, current - 1, current, () => {
                      setTimeout(countUp, 300 + Math.random() * 200);
                    });
                  } else {
                    // Add the plus sign to the first digit after counting completes
                    if (index === 0) {
                      el.parentElement.classList.add('show-plus');
                    }
                  }
                }
                
                countUp();
              }
            }
            
            // Start with initial flicker
            changeDigit(el, 0, Math.floor(Math.random() * 10), () => {
              i++;
              setTimeout(flicker, 400);
            });
          }, warmup);
        });
      }
      
      // Setup Intersection Observer
      const io = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (!entry.isIntersecting) return;
          
          const el = entry.target;
          
          // Check if this is part of a multi-digit group
          const tubeGroup = el.closest('.tube-group');
          if (tubeGroup.querySelectorAll('.tube').length > 1) {
            // This is a multi-digit display
            const targetNumber = 130; // For our specific case
            animateMultiDigit(tubeGroup, targetNumber);
          } else {
            // This is a single digit
            const target = parseInt(el.getAttribute('data-target'), 10) || 0;
            animateSingleDigit(el, target);
          }
          
          observer.unobserve(el);
        });
      }, { threshold: 0.4 });
      
      // Observe single digit tubes
      singleDigitTubes.forEach(c => io.observe(c));
      
      // Observe the first digit of multi-digit groups
      document.querySelectorAll('.tube-group:has(.tube:nth-child(2)) .number:first-child').forEach(c => io.observe(c));
      
      // Add subtle parallax effect on mouse move
      document.querySelectorAll('.tube').forEach(tube => {
        tube.addEventListener('mousemove', (e) => {
          const rect = tube.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          
          const moveX = (x - centerX) / 20;
          const moveY = (y - centerY) / 20;
          
          const numberContainer = tube.querySelector('.number-container');
          if (numberContainer) {
            numberContainer.style.transform = `translateZ(-20px) translateX(${moveX}px) translateY(${moveY}px)`;
          }
        });
        
        tube.addEventListener('mouseleave', () => {
          const numberContainer = tube.querySelector('.number-container');
          if (numberContainer) {
            numberContainer.style.transform = 'translateZ(-20px)';
          }
        });
      });
    });
  </script>
</body>
</html>